# Path: src/sutta_processor/optimizer/pool_manager.py
import json
import logging
from typing import Dict, Any, List, Set
from .config import PRIMARY_BOOKS_SET, JS_OUTPUT_DIR, PRIMARY_BOOKS_LIST

logger = logging.getLogger("Optimizer.Pools")

class PoolManager:
    def __init__(self):
        self.sutta_books: Set[str] = set()
        
        # [OPTIMIZED] Loại bỏ 'primary' list để tránh duplicate data.
        # Client sẽ tự tổng hợp Primary Pool từ 'books' dựa trên config.
        self.pools: Dict[str, Any] = {
            "books": {} 
        }

    def register_sutta_books(self, super_data: Dict[str, Any]):
        def _extract(node, collection):
            if isinstance(node, str): collection.add(node)
            elif isinstance(node, list):
                for x in node: _extract(x, collection)
            elif isinstance(node, dict):
                for v in node.values(): _extract(v, collection)

        structure = super_data.get("structure", [])
        
        # [FIX] Handle new nested 'tpk' root structure
        if isinstance(structure, dict) and "tpk" in structure:
            structure = structure["tpk"]
            
        # Ensure we are iterating a list (legacy structure was list directly)
        if isinstance(structure, list):
            for item in structure:
                if isinstance(item, dict) and "sutta" in item:
                    _extract(item["sutta"], self.sutta_books)
                    break

    @staticmethod
    def filter_smart_uids(raw_content: Dict[str, Any], meta_map: Dict[str, Any]) -> List[str]:
        candidates = set(raw_content.keys())
        blacklist_parents = set()

        for uid, info in meta_map.items():
            if info.get("type") == "shortcut":
                parent = info.get("parent_uid")
                target = info.get("scroll_target")
                
                if target:
                    candidates.add(uid)
                    if parent: blacklist_parents.add(parent)

        return sorted([u for u in candidates if u not in blacklist_parents])

    def merge_worker_result(self, book_id: str, valid_uids: List[str]):
        """
        [OPTIMIZED] Chỉ lưu vào pool của từng sách.
        Không cộng dồn vào primary pool nữa.
        """
        if not book_id: return
        
        # Add to book pool
        if book_id not in self.pools["books"]:
            self.pools["books"][book_id] = []
        self.pools["books"][book_id].extend(valid_uids)

        # [REMOVED] Logic add to 'primary' is gone.

    def generate_js_constants(self):
        secondary = sorted(list(self.sutta_books - PRIMARY_BOOKS_SET))
        file_path = JS_OUTPUT_DIR / "data" / "constants.js"
        file_path.parent.mkdir(parents=True, exist_ok=True)

        content = (
            "// Path: web/assets/modules/data/constants.js\n"
            "// Auto-generated by SuttaProcessor\n\n"
            f"export const PRIMARY_BOOKS = {json.dumps(PRIMARY_BOOKS_LIST, indent=2)};\n\n"
            f"export const SECONDARY_BOOKS = {json.dumps(secondary, indent=2)};\n"
        )
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(content)
        logger.info(f"   ✨ Generated JS Constants")