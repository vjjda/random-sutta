# Path: src/sutta_processor/optimizer/pool_manager.py
import json
import logging
from typing import Dict, Set, List
from .config import JS_OUTPUT_DIR, PRIMARY_BOOKS_LIST, PRIMARY_BOOKS_SET

logger = logging.getLogger("Optimizer.Pools")

class PoolManager:
    def __init__(self):
        self.book_counts: Dict[str, int] = {}
        # Danh sách sách lý thuyết thuộc Sutta Pitaka (lấy từ Super Tree)
        self.sutta_universe: Set[str] = set()

    def register_book_count(self, book_id: str, count: int, sub_counts: Dict[str, int] = None) -> None:
        """
        Lưu số lượng bài.
        Hỗ trợ cả sách thường (count) và sách gộp (sub_counts).
        """
        if sub_counts:
            self.book_counts.update(sub_counts)
        elif count >= 0:
            self.book_counts[book_id] = count

    def set_sutta_universe(self, books: List[str]) -> None:
        """Nhận danh sách sách Sutta từ Orchestrator (quét super_book)."""
        self.sutta_universe = set(books)

    def generate_js_constants(self) -> None:
        """
        Sinh file constants.js.
        Logic: Secondary = (Sutta Universe - Primary) INTERSECT Processed Books
        """
        # 1. Xác định ứng viên Secondary (Theo lý thuyết)
        # Loại bỏ Primary (DN, MN, AN, SN...) ra khỏi vũ trụ Sutta
        theoretical_secondary = self.sutta_universe - PRIMARY_BOOKS_SET
        
        # 2. Kiểm tra thực tế (Sách phải có dữ liệu)
        valid_secondary = []
        for book_id in theoretical_secondary:
            # Kiểm tra xem sách có trong book_counts không
            # Lưu ý: Các sách Vinaya/Abhidhamma dù có trong book_counts cũng sẽ bị loại 
            # vì chúng không nằm trong theoretical_secondary (vũ trụ Sutta).
            if self.book_counts.get(book_id, 0) > 0:
                valid_secondary.append(book_id)

        sorted_secondary = sorted(valid_secondary)
        
        # 3. Tạo Group Map cho AN/SN (Optional, giúp UI)
        book_groups = {}
        for book_id in self.book_counts.keys():
            for p_book in ["an", "sn"]: # Hardcode primary groups
                if book_id.startswith(p_book) and book_id != p_book:
                    if p_book not in book_groups: book_groups[p_book] = []
                    book_groups[p_book].append(book_id)
        
        for k in book_groups:
            book_groups[k].sort(key=lambda x: (len(x), x)) # Sort an1, an2, an10

        content = (
            "// Path: web/assets/modules/data/constants.js\n"
            "// Auto-generated by SuttaProcessor\n\n"
            f"export const PRIMARY_BOOKS = {json.dumps(PRIMARY_BOOKS_LIST, indent=2)};\n\n"
            f"export const SECONDARY_BOOKS = {json.dumps(sorted_secondary, indent=2)};\n\n"
            f"export const BOOK_GROUPS = {json.dumps(book_groups, indent=2)};\n\n"
            "// Map: { book_id: valid_sutta_count }\n"
            f"export const SUTTA_COUNTS = {json.dumps(self.book_counts, indent=2, sort_keys=True)};\n"
        )

        file_path = JS_OUTPUT_DIR / "data" / "constants.js"
        file_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(content)
            
        logger.info(f"   ✨ Generated constants.js (Secondary: {len(sorted_secondary)} books)")